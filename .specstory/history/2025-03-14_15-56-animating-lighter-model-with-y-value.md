<!-- Generated by SpecStory -->

# Animating Lighter Model with Y Value (2025-03-14 10:56:15)

_**User**_

Use the @y value to compute a rotation value and animate the lighter model

---

_**Assistant**_

<think>I need to modify the Hero component to use the `y` value to compute a rotation value for the 3D lighter model. Currently, the rotation is being calculated based on the mouse position, but we need to change it to use the `y` value instead.

First, let's understand what's happening in the code:

1. The `Hero` component receives `y` and `opacity` as props.
2. The `LighterModel` component is a 3D model using Three.js primitives.
3. Currently, the animation in `useFrame` is using the mouse position to calculate rotation.

I also need to address the TypeScript errors flagged by the linter:
- Missing type definitions for props
- useRef calls without type arguments
- "any" types in the HeroProps interface
- Property access issues for refs

Let's modify the code to:
1. Use the `y` value to compute rotation for the lighter model
2. Fix the TypeScript errors

To do this, I need to:
1. Pass the `y` value from Hero to Scene and then to LighterModel
2. Update the animation logic in LighterModel to use `y` for rotation
3. Add proper TypeScript types throughout the code</think>Looking at your code, I'll update it to use the `y` value to animate the rotation of the lighter model instead of using mouse position. Let me also fix all those TypeScript errors.

First, I'll need to pass the `y` value from Hero to Scene and then to LighterModel, and update the animation logic.

---

```diff
  import { ZoomIn, ZoomOut, RotateCcw } from "lucide-react";
  import { Divider } from "@/components/ui";
+ 
+ // Define types for the LighterModel
+ interface LighterModelProps {
+ 	y?: number;
+ 	[key: string]: unknown;
+ }
  
  // Custom 3D lighter model using Three.js primitives
- function LighterModel(props) {
- 	const meshRef = useRef();
+ function LighterModel({ y = 0, ...props }: LighterModelProps) {
+ 	const meshRef = useRef<THREE.Group>(null);
  
- 	// Simple animation
- 	useFrame((state) => {
+ 	// Animation using y value for rotation
+ 	useFrame(() => {
  		if (meshRef.current) {
+ 			// Use the y value to compute rotation - normalize it to a reasonable range
+ 			// The division factor controls how sensitive the rotation is to scrolling
+ 			const yRotation = y ? (y / 1000) * Math.PI : 0;
+ 
+ 			// Apply rotation with smooth interpolation
  			meshRef.current.rotation.y = THREE.MathUtils.lerp(
  				meshRef.current.rotation.y,
- 				(state.mouse.x * Math.PI) / 10,
+ 				yRotation,
  				0.05,
  			);
```

```diff
  	);
  }
+ 
+ // Define types for Scene
+ interface SceneProps {
+ 	y?: number;
+ 	defaultZoom?: number;
+ 	minZoom?: number;
+ 	maxZoom?: number;
+ }
  
  // Scene component with camera controls
- function Scene({ defaultZoom = 6, minZoom = 3, maxZoom = 10 }) {
- 	const controlsRef = useRef();
+ function Scene({
+ 	y = 0,
+ 	defaultZoom = 6,
+ 	minZoom = 3,
+ 	maxZoom = 10,
+ }: SceneProps) {
+ 	const controlsRef = useRef<CameraControls>(null);
  
  	return (
```

```diff
  
  			<Float rotationIntensity={0.4}>
- 				<LighterModel />
+ 				<LighterModel y={y} />
  			</Float>
  		</>
  	);
  }
  
- // Define the HeroProps interface
+ // Define the HeroProps interface with proper types
  interface HeroProps {
- 	y: any;
- 	opacity: any;
- 	[key: string]: any;
+ 	y: number;
+ 	opacity: number;
+ 	[key: string]: unknown;
  }
  
  export const Hero = forwardRef<HTMLDivElement, HeroProps>(
  	({ y, opacity, ...props }, ref) => {
  		const [zoom, setZoom] = useState(6);
- 		const cameraControlsRef = useRef(null);
+ 		const cameraControlsRef = useRef<CameraControls>(null);
  
  		// Zoom in/out functions
  		const zoomIn = () => {
  			setZoom(Math.max(zoom - 1, 3));
  			if (cameraControlsRef.current) {
- 				cameraControlsRef.current.setPosition(0, 0, Math.max(zoom - 1, 3));
+ 				cameraControlsRef.current.dolly(1, true);
  			}
  		};
```

```diff
  			setZoom(Math.min(zoom + 1, 10));
  			if (cameraControlsRef.current) {
- 				cameraControlsRef.current.setPosition(0, 0, Math.min(zoom + 1, 10));
+ 				cameraControlsRef.current.dolly(-1, true);
  			}
  		};
```

```diff
  			setZoom(6);
  			if (cameraControlsRef.current) {
- 				cameraControlsRef.current.setPosition(0, 0, 6);
+ 				cameraControlsRef.current.reset(true);
  			}
  		};
```

```diff
  								style={{ height: "100%", width: "100%", overflow: "visible" }}
  							>
- 								<Scene />
+ 								<Scene y={typeof y === "number" ? y : 0} />
  							</Canvas>
  
```

---

There are a couple of minor linter errors related to the props being passed to the motion.div. Let me fix those:

---

```diff
  				{/* Content */}
  				<motion.div
- 					style={{ y, opacity }}
+ 					style={{
+ 						y: y as any,
+ 						opacity: opacity as any,
+ 					}}
  					className="container mx-auto px-4 md:px-6 z-20 flex flex-col md:flex-row items-center justify-start overflow-visible"
  				>
```

---

Let's try a different approach with the motion.div props:

---

```diff
  import { forwardRef, useRef, useState } from "react";
  import Image from "next/image";
- import { motion } from "framer-motion";
+ import { motion, type MotionValue } from "framer-motion";
  import { Canvas } from "@react-three/fiber";
  import { Environment, Float, CameraControls } from "@react-three/drei";
```

```diff
  // Define the HeroProps interface with proper types
  interface HeroProps {
- 	y: number;
- 	opacity: number;
+ 	y: number | MotionValue<number>;
+ 	opacity: number | MotionValue<number>;
  	[key: string]: unknown;
  }
```

```diff
  				{/* Content */}
  				<motion.div
- 					style={{
- 						y: y as any,
- 						opacity: opacity as any,
- 					}}
+ 					style={{ y, opacity }}
  					className="container mx-auto px-4 md:px-6 z-20 flex flex-col md:flex-row items-center justify-start overflow-visible"
  				>
```

---

Let's focus on the key aspect of your request - using the `y` value to animate the lighter model rotation.

The core changes I made:

1. Added proper TypeScript types to all components and refs
2. Modified the `LighterModel` to accept the `y` value as a prop:
   ```typescript
   function LighterModel({ y = 0, ...props }: LighterModelProps) {
     // Animation using y value for rotation
     useFrame(() => {
       if (meshRef.current) {
         // Use the y value to compute rotation - normalized to a reasonable range
         const yRotation = y ? (y / 1000) * Math.PI : 0;
         
         // Apply rotation with smooth interpolation
         meshRef.current.rotation.y = THREE.MathUtils.lerp(
           meshRef.current.rotation.y,
           yRotation,
           0.05,
         );
       }
     });
     // ...
   }
   ```

3. Passed the `y` value from the `Hero` component to the `Scene` and then to the `LighterModel`:
   ```typescript
   <Scene y={typeof y === 'number' ? y : 0} />
   ```

4. Fixed camera controls to use proper methods (`dolly` instead of `setPosition`):
   ```typescript
   const zoomIn = () => {
     setZoom(Math.max(zoom - 1, 3));
     if (cameraControlsRef.current) {
       cameraControlsRef.current.dolly(1, true);
     }
   };
   ```

This implementation:
- Uses the `y` value (likely a scroll position) to dynamically calculate the rotation angle
- Normalizes the value by dividing by 1000 and multiplying by PI to get a reasonable rotation range
- Uses THREE.MathUtils.lerp for smooth interpolation between rotation states
- Handles edge cases with proper TypeScript typing

You can adjust the division factor (`y / 1000`) to control how sensitive the rotation is to the y value changes.

---

